<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>同一网络文本互传</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 20px auto; padding: 0 20px; }
        .container { margin: 20px 0; }
        input, textarea, button { width: 100%; padding: 10px; margin: 5px 0; box-sizing: border-box; border: 1px solid #ddd; border-radius: 4px; }
        textarea { height: 150px; resize: none; }
        button { background: #2196F3; color: white; border: none; cursor: pointer; font-size: 16px; }
        button:hover { background: #1976D2; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        #receiveArea { background: #f9f9f9; }
        #connInfo { color: #2E7D32; font-weight: bold; margin: 10px 0; padding: 10px; background: #f0f9f0; border-radius: 4px; }
        .tip { color: #666; font-size: 14px; margin: 5px 0; }
    </style>
</head>
<body>
    <h1>同一网络文本互传</h1>

    <!-- 连接控制区 -->
    <div class="container">
        <button id="createBtn">创建连接（主机）</button>
        <div class="tip">提示：主机创建后，其他设备点下方“加入连接”并输入主机的“连接标识”</div>
        
        <div style="margin-top: 20px;">
            <input type="text" id="joinCodeInput" placeholder="输入主机的连接标识">
            <button id="joinBtn">加入连接（客户）</button>
        </div>
        
        <div id="connInfo" style="display: none;"></div>
    </div>

    <!-- 文本发送区 -->
    <div class="container">
        <h3>发送文本</h3>
        <textarea id="sendText" placeholder="输入要发送的文本..."></textarea>
        <button id="sendBtn" disabled>发送</button>
    </div>

    <!-- 文本接收区 -->
    <div class="container">
        <h3>接收文本</h3>
        <textarea id="receiveArea" readonly placeholder="等待接收文本..."></textarea>
    </div>

    <script>
        // 核心变量
        let peerConn;
        let dataChan;
        let hostConnCode = ''; // 主机连接标识
        const iceConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' }, // 公共STUN，获取局域网地址
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        // DOM元素
        const createBtn = document.getElementById('createBtn');
        const joinBtn = document.getElementById('joinBtn');
        const joinCodeInput = document.getElementById('joinCodeInput');
        const connInfo = document.getElementById('connInfo');
        const sendText = document.getElementById('sendText');
        const sendBtn = document.getElementById('sendBtn');
        const receiveArea = document.getElementById('receiveArea');

        // 初始化：获取本地IP（用于生成连接标识）
        async function getLocalIP() {
            try {
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                return data.ip;
            } catch (e) {
                // 若外网IP获取失败，用简单随机标识
                return 'LOCAL-' + Math.floor(Math.random() * 10000);
            }
        }

        // 主机：创建连接
        createBtn.addEventListener('click', async () => {
            // 生成唯一连接标识（本地IP+随机数，同一网络可识别）
            const localIP = await getLocalIP();
            hostConnCode = localIP + '-' + Math.floor(Math.random() * 1000).toString().padStart(3, '0');
            
            // 显示连接标识，告知其他设备
            connInfo.textContent = `主机连接标识：${hostConnCode} | 其他设备输入此标识加入`;
            connInfo.style.display = 'block';

            // 初始化Peer连接和数据通道
            peerConn = new RTCPeerConnection(iceConfig);
            createDataChannel();
            bindPeerEvents();

            // 创建Offer（主动发起连接协商）
            peerConn.createOffer()
                .then(offer => peerConn.setLocalDescription(offer))
                .then(() => {
                    // 存储主机Offer，供客户端加入时使用（用localStorage模拟“临时存储”，同一网络通过标识匹配）
                    localStorage.setItem(`p2p_offer_${hostConnCode}`, JSON.stringify(peerConn.localDescription));
                    console.log('主机Offer已生成，等待客户端加入');
                })
                .catch(err => alert('创建连接失败：' + err.message));
        });

        // 客户端：加入连接
        joinBtn.addEventListener('click', () => {
            const targetCode = joinCodeInput.value.trim();
            if (!targetCode) {
                alert('请输入主机的连接标识');
                return;
            }

            // 从localStorage获取主机的Offer（同一网络下，浏览器localStorage共享此标识对应的Offer）
            const hostOfferStr = localStorage.getItem(`p2p_offer_${targetCode}`);
            if (!hostOfferStr) {
                alert('未找到此连接标识的主机，请确认标识正确且主机已创建连接');
                return;
            }
            const hostOffer = JSON.parse(hostOfferStr);

            // 初始化Peer连接，响应主机Offer
            peerConn = new RTCPeerConnection(iceConfig);
            bindPeerEvents();

            // 设置主机Offer为远程描述，生成Answer
            peerConn.setRemoteDescription(new RTCSessionDescription(hostOffer))
                .then(() => peerConn.createAnswer())
                .then(answer => peerConn.setLocalDescription(answer))
                .then(() => {
                    // 将客户端Answer存储，供主机获取
                    localStorage.setItem(`p2p_answer_${targetCode}`, JSON.stringify(peerConn.localDescription));
                    console.log('客户端Answer已生成，等待主机确认');
                    
                    // 轮询获取主机的ICE候选，完成连接
                    startIceCandidatePoll(targetCode);
                })
                .catch(err => alert('加入连接失败：' + err.message));
        });

        // 轮询获取ICE候选（无服务器时，用localStorage模拟“消息传递”）
        function startIceCandidatePoll(connCode) {
            const pollInterval = setInterval(() => {
                // 客户端获取主机的ICE候选
                const hostIce = localStorage.getItem(`p2p_ice_host_${connCode}`);
                if (hostIce) {
                    const iceCandidate = new RTCIceCandidate(JSON.parse(hostIce));
                    peerConn.addIceCandidate(iceCandidate)
                        .catch(err => console.error('添加ICE候选失败：', err));
                    localStorage.removeItem(`p2p_ice_host_${connCode}`); // 避免重复添加
                }

                // 主机获取客户端的ICE候选
                const clientIce = localStorage.getItem(`p2p_ice_client_${connCode}`);
                if (clientIce && createBtn.disabled) {
                    const iceCandidate = new RTCIceCandidate(JSON.parse(clientIce));
                    peerConn.addIceCandidate(iceCandidate)
                        .catch(err => console.error('添加ICE候选失败：', err));
                    localStorage.removeItem(`p2p_ice_client_${connCode}`);
                }

                // 主机获取客户端的Answer，完成协商
                const clientAnswer = localStorage.getItem(`p2p_answer_${connCode}`);
                if (clientAnswer && createBtn.disabled) {
                    peerConn.setRemoteDescription(new RTCSessionDescription(JSON.parse(clientAnswer)))
                        .then(() => {
                            clearInterval(pollInterval);
                            alert('连接成功！可开始发送文本');
                        });
                    localStorage.removeItem(`p2p_answer_${connCode}`);
                }

                // 连接成功后停止轮询
                if (dataChan && dataChan.readyState === 'open') {
                    clearInterval(pollInterval);
                }
            }, 1000);
        }

        // 创建数据通道（主机端）
        function createDataChannel() {
            dataChan = peerConn.createDataChannel('textTransfer');
            initDataChannelEvents();
        }

        // 绑定数据通道事件（接收/发送逻辑）
        function initDataChannelEvents() {
            // 接收文本
            dataChan.onmessage = (e) => {
                const time = new Date().toLocaleTimeString();
                receiveArea.value += `对方（${time}）：\n${e.data}\n\n`;
                receiveArea.scrollTop = receiveArea.scrollHeight; // 滚动到底部
            };

            // 连接成功，启用发送按钮
            dataChan.onopen = () => {
                sendBtn.disabled = false;
                createBtn.disabled = true;
                joinBtn.disabled = true;
                connInfo.textContent = '✅ 已连接，可正常发送文本';
                connInfo.style.color = '#2E7D32';
            };

            // 连接断开
            dataChan.onclose = () => {
                alert('连接已断开');
                resetState();
            };
        }

        // 绑定PeerConnection事件（ICE候选、数据通道回调等）
        function bindPeerEvents() {
            // 客户端接收主机的数据通道
            peerConn.ondatachannel = (e) => {
                dataChan = e.channel;
                initDataChannelEvents();
            };

            // 生成ICE候选（局域网地址信息），存储供对方获取
            peerConn.onicecandidate = (e) => {
                if (e.candidate) {
                    const iceStr = JSON.stringify(e.candidate);
                    // 主机的ICE存到host_ice，客户端的存到client_ice
                    if (createBtn.disabled) {
                        localStorage.setItem(`p2p_ice_host_${hostConnCode}`, iceStr);
                    } else {
                        localStorage.setItem(`p2p_ice_client_${joinCodeInput.value.trim()}`, iceStr);
                    }
                }
            };

            // 连接状态变化
            peerConn.onconnectionstatechange = () => {
                if (peerConn.connectionState === 'connected') {
                    console.log('P2P连接已建立');
                } else if (peerConn.connectionState === 'disconnected') {
                    resetState();
                }
            };
        }

        // 发送文本
        sendBtn.addEventListener('click', () => {
            const text = sendText.value.trim();
            if (!text) return;
            
            // 发送给对方
            dataChan.send(text);
            
            // 自己的文本显示在接收区
            const time = new Date().toLocaleTimeString();
            receiveArea.value += `我（${time}）：\n${text}\n\n`;
            receiveArea.scrollTop = receiveArea.scrollHeight;
            
            // 清空输入框
            sendText.value = '';
        });

        // 重置状态（连接断开后）
        function resetState() {
            sendBtn.disabled = true;
            createBtn.disabled = false;
            joinBtn.disabled = false;
            connInfo.style.display = 'none';
            if (peerConn) {
                peerConn.close();
                peerConn = null;
            }
            if (dataChan) {
                dataChan.close();
                dataChan = null;
            }
        }
    </script>
</body>
</html>

